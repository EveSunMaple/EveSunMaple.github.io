---
abbrlink: ''
categories:
- - OI学习笔记
- - 图论
date: '2023-06-27T14:23:49.567398+08:00'
tags:
- Tarjan
- 图论
- OI
- C++
- 割点
- 割边
- 连通分量
- 无向图
title: 【图论】割边与割点
updated: 2023-6-27T14:31:22.259+8:0
---
## 概念

在无向图中，
割点：去掉一个点及与其相邻的所有边，无向图中的[连通分量](https://www.saroprock.com/post/3a57de4f.html)增加，则称该点为割点。
割边：去掉一条边，无向图中的连通分量增加，则称该边为割边。
割点与割边的关系
1.有割点不一定有割边，有割边一定有割点。
2.割边的两个端点中一定有一个是割点。

## 求解思路

> 割点与割边的求解都使用[Tarjan](https://www.saroprock.com/tags/Tarjan/)算法实现

### 求割边

求解割边的方法与求解有向图中的强连通分量十分相似，我们可以在原有基础上修改。为什么这样说呢？

#### 理论前提

我们回顾一下割边的定义，如果去掉这条边，这个图变成了不连通的两个独立的部分。这说明这两部分之间只通过这一条边连接，反过来说就是有两条边连接的两个部分中不存在割边。这就与我们有向图中的强连通分量很像了，我们也可以通过DFS树+顶点表示法来表示一个割边。

虽然这是一幅无向图，但实际上在DFS的过程中就已经有了DFS序，我们也与有向图的DFS树一样有树边与非树边的区别。那么我们现在所有的形式其实与求解强连通分量一样了：给每个结点打上它的DFS序和可以回到的结点序，如果两个不一样，说明它与它能回到的结点之间有两条通路连接——说明它们两个之间的边都不可能是割边，因为树边已经连接了里面的所有点，加上这一条非树边，那么每个点到其他点都有了两条通路，不管割掉那一条边都不管用。

#### 算法实现

因为是无向边，我们还要注意一个小问题——重边。不同于有向图中的重边，这个重边是会实实在在影响到我们的。比如原来两个点只有一条边相连，这样一条边显然是一条割边。但如果是重边呢？那它就不是割边了，我们需要特判这种情况，有两个选择：

1. 使用vector，给每一条边加上id值，注意添加无向边时两个有向边的结点是相同的，因为它们本质上是一条无向边：

   ```C++
   vector<vector<pair<int, int>>> g(N); // 建图
   for(auto i : g[j]); // 遍历
   ```
2. 换用链式前向星，因为链式前向星自带id，不用多占空间速度还快，是很好的选择。不过由于一条无向边使用两条有向边"聚合"而成，我们先把边数tot赋值为1，这样只需要通过按位异或就可以判断其属于哪一个结点了：

   ```C++
   int tot = 1; // 注意赋值为一

   struct node
   {
       int ver;
       int nxt;
   }edge[N * 2];

   void add(int u, int v)
   {
       edge[++tot].ver = v;
       edge[tot].nxt = head[u];
       head[u] = tot;
   }

   //示例，判断id为a和b的结点是不是同一条无向边
   if(i == (from ^ 1))......
   ```
