---
title: 【动态规划】LIS与LCS（最长上升子序列）
tags: ['DP', '线性动态规划', 'C++', 'OI']
categories:
  - OI学习笔记
  - 动态规划
date: 2023-05-14 00:00:00
---

## 引子-LIS问题

这几天在学习**DP（动态规划）**，里面第一个接触到的问题就是**LIS**问题，这里简单概述如下:

>给定一个长度为$N$的数列$A$，求数值单调递增的子序列的的长度最长是多少？

其中LIS（最长上升子序列）指的是从序列A中选择若干个i，使得$i_{1}<i_{2}<i_{3}...<i_{n}$的同时满足$A_{i_{1}}<A_{i_{2}}<A_{i_{3}}...<A_{i_{n}}$。

---

### LIS的朴素解法

这里给出一道LIS模板题：[导弹拦截](https://www.luogu.com.cn/problem/P1020)

最朴素的想法就是用一个数组$DP[i]$表示在$1-i$范围内的LIS长度，初始化$DP[i]$为$1$（它自己一个数作为一个LIS）。如果在小于$1-i$的范围内有满足LIS定义的情况，就可以转移$DP[i]$的值，代表选入这个范围和$A[i]$做为LIS的一部分。 

我们要遍历到$DP[i]$时同时遍历所有在$1-i$内的状态，显然每次转移都是$O(N)$的时间复杂度，总复杂度为$O(N^2)$，状态转移方程如下：

$DP[i] = max(DP[i], DP[j] + 1) | (j < i)$ 

显然$O(N^2)$的时间复杂度是无法满足OIer的，因此我们要进行优化。

### LIS的贪心二分优化

#### 优化思路

为什么朴素算法慢呢？因为我们把**所有**情况枚举了一遍，而最后留下的只有一种。LIS的朴素算法在那些本不需要枚举的状态上浪费了时间，自然就不行了。

我们知道，LIS是一个严格单增的数列，那么在两个LIS长度相同的情况下，我们希望它**能扩展到的长度**尽可能长，自然是希望**LIS结尾元素尽可能小**。那么思路就有了，我们使用一个数组$G[i]$保存长度为$i$的LIS的结尾元素值，每次遍历到$DP[i]$，先查询一下当前$G[i]$的值，如果$A[i]$值比$G[i]$大，说明我们可以立刻更新$G[i + 1]$的值；如果比

>此文章未完工